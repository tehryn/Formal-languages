\hypertarget{group__expression__processing}{}\section{Expression processing}
\label{group__expression__processing}\index{Expression processing@{Expression processing}}


Precedence analysis and expression processing of the language I\+F\+J16.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structstack__expresion}{stack\+\_\+expresion}
\begin{DoxyCompactList}\small\item\em Structure for stack of tokens. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__expression__processing_gad39ffaaf2f15904baf361c8a95eea23f}{E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG}~0
\item 
\#define {\bfseries E\+R\+R\+\_\+\+L\+E\+X\+I\+C\+A\+L\+\_\+\+A\+N\+A\+L\+Y\+S\+IS}~1\hypertarget{group__expression__processing_gae1b0d4386e23ff5b3e5a2f2d3bb2e595}{}\label{group__expression__processing_gae1b0d4386e23ff5b3e5a2f2d3bb2e595}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+S\+Y\+N\+T\+A\+C\+T\+I\+C\+\_\+\+A\+N\+A\+L\+Y\+S\+IS}~2\hypertarget{group__expression__processing_ga65bbcacac1fab0692da94892852f763f}{}\label{group__expression__processing_ga65bbcacac1fab0692da94892852f763f}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+S\+E\+M\+\_\+\+N\+D\+E\+F\+\_\+\+R\+E\+D\+EF}~3\hypertarget{group__expression__processing_ga48c742e0bcd4765bff4dff57adaf4ea3}{}\label{group__expression__processing_ga48c742e0bcd4765bff4dff57adaf4ea3}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+S\+E\+M\+\_\+\+C\+O\+M\+P\+A\+T\+I\+B\+I\+L\+I\+TY}~4\hypertarget{group__expression__processing_ga8f52bafe7d43e6354bae75d2caa5a3e1}{}\label{group__expression__processing_ga8f52bafe7d43e6354bae75d2caa5a3e1}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+S\+E\+M\+\_\+\+O\+T\+H\+E\+RS}~6\hypertarget{group__expression__processing_ga1618901d33a81fae88c01635dc5cef54}{}\label{group__expression__processing_ga1618901d33a81fae88c01635dc5cef54}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+I\+N\+P\+U\+T\+\_\+\+N\+U\+M\+B\+ER}~7\hypertarget{group__expression__processing_ga43ec102bd6ec2f2858cd4e1a4dbf6742}{}\label{group__expression__processing_ga43ec102bd6ec2f2858cd4e1a4dbf6742}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+U\+N\+I\+N\+I\+C\+I\+A\+L\+I\+Z\+E\+D\+\_\+\+V\+AR}~8\hypertarget{group__expression__processing_ga28cd80ee0db6b3d64692d4b0ec19a6c4}{}\label{group__expression__processing_ga28cd80ee0db6b3d64692d4b0ec19a6c4}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+D\+I\+V\+I\+S\+I\+O\+N\+\_\+\+Z\+E\+RO}~9\hypertarget{group__expression__processing_ga7226d4889da856a935d6749b45778022}{}\label{group__expression__processing_ga7226d4889da856a935d6749b45778022}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+O\+T\+H\+E\+RS}~10\hypertarget{group__expression__processing_ga18dd2f4dc443436ec22915d1a2ff1667}{}\label{group__expression__processing_ga18dd2f4dc443436ec22915d1a2ff1667}

\item 
\#define {\bfseries E\+R\+R\+\_\+\+I\+N\+T\+E\+R\+N\+\_\+\+F\+A\+U\+LT}~99\hypertarget{group__expression__processing_ga81c0b2aff83c4ff667ff4fe7bb17fe26}{}\label{group__expression__processing_ga81c0b2aff83c4ff667ff4fe7bb17fe26}

\item 
\#define \hyperlink{group__expression__processing_gad00ce6a1d92b76fec757cc05ca401c20}{F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR}(message,  error\+\_\+code)
\item 
\#define \hyperlink{group__expression__processing_gaefbe6596bcbb11c624652e80c37ec88a}{S\+T\+R\+D\+UP}(l,  s)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{group__expression__processing_ga4c57a10caa30f485a261625f53528f37}{expr\+\_\+analyze} (\hyperlink{structtoken}{token} t\+\_\+in, \hyperlink{structtoken}{token} $\ast$t\+\_\+out, char $\ast$class\+\_\+name, int error\+\_\+6\+\_\+flag, \hyperlink{structtoken}{token} $\ast$$\ast$postfix\+\_\+token\+\_\+array, int $\ast$token\+\_\+count, int $\ast$expr\+\_\+data\+\_\+type, \hyperlink{structhtab__t}{htab\+\_\+t} $\ast$global\+\_\+table, \hyperlink{structhtab__t}{htab\+\_\+t} $\ast$local\+\_\+table,...)
\begin{DoxyCompactList}\small\item\em Function analyzes precedence and converts expression to postfix format. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_gaff5002c4bf81b10b720b056aa0b70c5a}{stack\+\_\+expression\+\_\+init} (struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s, int size)
\begin{DoxyCompactList}\small\item\em Function initializes a stack, allocates required memory and sets its variables. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga9fa5406eb5ecac559c4f4c6d36065fb6}{stack\+\_\+expression\+\_\+destroy} (struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s)
\begin{DoxyCompactList}\small\item\em Function destroys a stack, frees its memory and sets its variables. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga938c2a69430813da1181adce149b6a5b}{stack\+\_\+expression\+\_\+empty} (const struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s)
\begin{DoxyCompactList}\small\item\em Function checks whether stack is empty. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_gae241e2aa86c0b655cdeccdc6ad115631}{stack\+\_\+expression\+\_\+full} (const struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s)
\begin{DoxyCompactList}\small\item\em Function checks whether stack is full. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga5798f0a7e7f62997286f1007791f7621}{stack\+\_\+expression\+\_\+top} (struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s, \hyperlink{structtoken}{token} $\ast$t)
\begin{DoxyCompactList}\small\item\em Function gives back top element from the stack. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga5185cf48c8ae8e8bc576dea6c0b59b4b}{stack\+\_\+expression\+\_\+pop} (struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s, \hyperlink{structtoken}{token} $\ast$t)
\begin{DoxyCompactList}\small\item\em Function pops and gives back top element from the stack. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_gaead604dfcdb459a972527f21b8074240}{stack\+\_\+expression\+\_\+push} (struct \hyperlink{structstack__expresion}{stack\+\_\+expresion} $\ast$s, \hyperlink{structtoken}{token} t)
\begin{DoxyCompactList}\small\item\em Function pushes given element to the stack. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga3d5f340d0eabb67c20b2018b509c527a}{operator\+\_\+priority} (int op)
\begin{DoxyCompactList}\small\item\em Function tells the priority of a given operator. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga42a0cd1f1765216b8bc8eee79b80c06d}{type\+\_\+priority} (int type)
\begin{DoxyCompactList}\small\item\em Function tells the priority of a given data type, which is later used for determining data type of the whole expression. \end{DoxyCompactList}\item 
int \hyperlink{group__expression__processing_ga78080bfa249f5c45571dbab511d17cc9}{type\+\_\+name\+\_\+convertion} (int type)
\begin{DoxyCompactList}\small\item\em Function converts names of the given data type, so it could be understood by the function \hyperlink{group__expression__processing_ga4c57a10caa30f485a261625f53528f37}{expr\+\_\+analyze()}. \end{DoxyCompactList}\item 
void \hyperlink{group__expression__processing_ga6414f4c43feeb08c5a2a71d5b7f41363}{print\+\_\+token} (\hyperlink{structtoken}{token} t, int id\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Function prints token value (and its id) to S\+T\+D\+E\+RR. This function is only used for debugging. \end{DoxyCompactList}\item 
void \hyperlink{group__expression__processing_ga9713b7493eade7529e743edaeafcc51c}{print\+\_\+token\+\_\+array} (\hyperlink{structtoken}{token} $\ast$arr, int id\+\_\+flag)
\begin{DoxyCompactList}\small\item\em Function prints array of tokens (and their ids) to S\+T\+D\+E\+RR. This function is only used for debugging. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Precedence analysis and expression processing of the language I\+F\+J16. 



\subsection{Macro Definition Documentation}
\index{Expression processing@{Expression processing}!E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG@{E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG}}
\index{E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG@{E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG}{ERR_WARNING}}]{\setlength{\rightskip}{0pt plus 5cm}\#define E\+R\+R\+\_\+\+W\+A\+R\+N\+I\+NG~0}\hypertarget{group__expression__processing_gad39ffaaf2f15904baf361c8a95eea23f}{}\label{group__expression__processing_gad39ffaaf2f15904baf361c8a95eea23f}
Error constants \index{Expression processing@{Expression processing}!F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR@{F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR}}
\index{F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR@{F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR}{FATAL_ERROR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+A\+T\+A\+L\+\_\+\+E\+R\+R\+OR(
\begin{DoxyParamCaption}
\item[{}]{message, }
\item[{}]{error\+\_\+code}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_gad00ce6a1d92b76fec757cc05ca401c20}{}\label{group__expression__processing_gad00ce6a1d92b76fec757cc05ca401c20}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{do} \{    \textcolor{keywordflow}{if}(ma1[0]!=NULL) free(ma1[0]); \textcolor{keywordflow}{if}(ma1[1]!=NULL) free(ma1[1]);   \(\backslash\)
                                                fputs((message), stderr);                                       
      \(\backslash\)
                                                return (error\_code); \} \textcolor{keywordflow}{while}(0)
\end{DoxyCode}
Macro frees alocated memory, prints error message and returns with given error code \index{Expression processing@{Expression processing}!S\+T\+R\+D\+UP@{S\+T\+R\+D\+UP}}
\index{S\+T\+R\+D\+UP@{S\+T\+R\+D\+UP}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{S\+T\+R\+D\+UP}{STRDUP}}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+T\+R\+D\+UP(
\begin{DoxyParamCaption}
\item[{}]{l, }
\item[{}]{s}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_gaefbe6596bcbb11c624652e80c37ec88a}{}\label{group__expression__processing_gaefbe6596bcbb11c624652e80c37ec88a}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{do} \{    \textcolor{keywordtype}{char} *tmp = (\textcolor{keywordtype}{char} *)\hyperlink{group__garbage__collector_gafc112ff977fb81bd172f5bb58bbcf19a}{mem\_alloc}( \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}) * ( strlen((\textcolor{keywordtype}{char} *)(s)) + 1 ) );               
      \(\backslash\)
                            if (tmp == NULL)                                                                            
      \hyperlink{group__expression__processing_gad00ce6a1d92b76fec757cc05ca401c20}{\(\backslash\)}
\hyperlink{group__expression__processing_gad00ce6a1d92b76fec757cc05ca401c20}{                                FATAL\_ERROR}(\textcolor{stringliteral}{"EXPRESSION: Memory could not be allocated.
       11\(\backslash\)n"}, ERR\_INTERN\_FAULT);        \(\backslash\)
                            else                                                                                        
      \(\backslash\)
                            \{                                                                                           
      \(\backslash\)
                                strcpy(tmp, (\textcolor{keywordtype}{char} *)(s));                                                               
      \(\backslash\)
                                (l) = tmp;                                                                              
      \(\backslash\)
                            \}                                                                                           
      \(\backslash\)
                        \} \textcolor{keywordflow}{while}(0)
\end{DoxyCode}
Macro that duolicates given string 

\subsection{Function Documentation}
\index{Expression processing@{Expression processing}!expr\+\_\+analyze@{expr\+\_\+analyze}}
\index{expr\+\_\+analyze@{expr\+\_\+analyze}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{expr\+\_\+analyze(token t\+\_\+in, token $\ast$t\+\_\+out, char $\ast$class\+\_\+name, int error\+\_\+6\+\_\+flag, token $\ast$$\ast$postfix\+\_\+token\+\_\+array, int $\ast$token\+\_\+count, int $\ast$expr\+\_\+data\+\_\+type, htab\+\_\+t $\ast$global\+\_\+table, htab\+\_\+t $\ast$local\+\_\+table,...)}{expr_analyze(token t_in, token *t_out, char *class_name, int error_6_flag, token **postfix_token_array, int *token_count, int *expr_data_type, htab_t *global_table, htab_t *local_table,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int expr\+\_\+analyze (
\begin{DoxyParamCaption}
\item[{{\bf token}}]{t\+\_\+in, }
\item[{{\bf token} $\ast$}]{t\+\_\+out, }
\item[{char $\ast$}]{class\+\_\+name, }
\item[{int}]{error\+\_\+6\+\_\+flag, }
\item[{{\bf token} $\ast$$\ast$}]{postfix\+\_\+token\+\_\+array, }
\item[{int $\ast$}]{token\+\_\+count, }
\item[{int $\ast$}]{expr\+\_\+data\+\_\+type, }
\item[{{\bf htab\+\_\+t} $\ast$}]{global\+\_\+table, }
\item[{{\bf htab\+\_\+t} $\ast$}]{local\+\_\+table, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga4c57a10caa30f485a261625f53528f37}{}\label{group__expression__processing_ga4c57a10caa30f485a261625f53528f37}


Function analyzes precedence and converts expression to postfix format. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em t\+\_\+in} & first token in an expression. \\
\hline
\mbox{\tt out}  & {\em t\+\_\+out} & last token red by the function, which is not contained in a final expression. \\
\hline
\mbox{\tt in}  & {\em class\+\_\+name} & name of a class, which contains processed expression. \\
\hline
\mbox{\tt in}  & {\em error\+\_\+6\+\_\+flag} & flag which determines whether error number 6 could be returned. \\
\hline
\mbox{\tt out}  & {\em postfix\+\_\+token\+\_\+array} & final postfix expression. \\
\hline
\mbox{\tt out}  & {\em token\+\_\+count} & number of tokens in a retuned expression array. \\
\hline
\mbox{\tt out}  & {\em expr\+\_\+data\+\_\+type} & data type of the retuned expression. \\
\hline
\mbox{\tt in}  & {\em global\+\_\+table} & global table of symbols. \\
\hline
\mbox{\tt in}  & {\em local\+\_\+table} & local table of symbols. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
class\+\_\+name!=N\+U\+LL 

global\+\_\+table!=N\+U\+LL 

local\+\_\+table!=N\+U\+LL 

error\+\_\+6\+\_\+flag==1 $\vert$$\vert$ error\+\_\+6\+\_\+flag==0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
postfix\+\_\+token\+\_\+array!=N\+U\+LL 

t\+\_\+out!=N\+U\+LL 

token\+\_\+count!=0 

postfix\+\_\+token\+\_\+array\mbox{[}token\+\_\+count-\/1\mbox{]}==E\+N\+D\+\_\+\+E\+X\+PR 
\end{DoxyPostcond}
\begin{DoxyReturn}{Returns}
integer value which tells, how the whole processed has been executed, 0 -\/$>$ no error, !=0 -\/$>$ error. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!operator\+\_\+priority@{operator\+\_\+priority}}
\index{operator\+\_\+priority@{operator\+\_\+priority}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{operator\+\_\+priority(int op)}{operator_priority(int op)}}]{\setlength{\rightskip}{0pt plus 5cm}int operator\+\_\+priority (
\begin{DoxyParamCaption}
\item[{int}]{op}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga3d5f340d0eabb67c20b2018b509c527a}{}\label{group__expression__processing_ga3d5f340d0eabb67c20b2018b509c527a}


Function tells the priority of a given operator. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em op} & operator symbol. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
op$>$=0 
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
integer value which tells the priority of a given operator. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!print\+\_\+token@{print\+\_\+token}}
\index{print\+\_\+token@{print\+\_\+token}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{print\+\_\+token(token t, int id\+\_\+flag)}{print_token(token t, int id_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}void print\+\_\+token (
\begin{DoxyParamCaption}
\item[{{\bf token}}]{t, }
\item[{int}]{id\+\_\+flag}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga6414f4c43feeb08c5a2a71d5b7f41363}{}\label{group__expression__processing_ga6414f4c43feeb08c5a2a71d5b7f41363}


Function prints token value (and its id) to S\+T\+D\+E\+RR. This function is only used for debugging. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em t} & token which should be printed. \\
\hline
\mbox{\tt in}  & {\em id\+\_\+flag} & value which determines whether the id of a token should be printed as well. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
id\+\_\+flag == 0 $\vert$$\vert$ id\+\_\+flag == 1 
\end{DoxyPrecond}
\index{Expression processing@{Expression processing}!print\+\_\+token\+\_\+array@{print\+\_\+token\+\_\+array}}
\index{print\+\_\+token\+\_\+array@{print\+\_\+token\+\_\+array}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{print\+\_\+token\+\_\+array(token $\ast$arr, int id\+\_\+flag)}{print_token_array(token *arr, int id_flag)}}]{\setlength{\rightskip}{0pt plus 5cm}void print\+\_\+token\+\_\+array (
\begin{DoxyParamCaption}
\item[{{\bf token} $\ast$}]{arr, }
\item[{int}]{id\+\_\+flag}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga9713b7493eade7529e743edaeafcc51c}{}\label{group__expression__processing_ga9713b7493eade7529e743edaeafcc51c}


Function prints array of tokens (and their ids) to S\+T\+D\+E\+RR. This function is only used for debugging. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em arr} & array of tokens which should be printed. \\
\hline
\mbox{\tt in}  & {\em id\+\_\+flag} & value which determines whether the id of a tokens should be printed as well. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
id\+\_\+flag == 0 $\vert$$\vert$ id\+\_\+flag == 1 
\end{DoxyPrecond}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+destroy@{stack\+\_\+expression\+\_\+destroy}}
\index{stack\+\_\+expression\+\_\+destroy@{stack\+\_\+expression\+\_\+destroy}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+destroy(struct stack\+\_\+expresion $\ast$s)}{stack_expression_destroy(struct stack_expresion *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+destroy (
\begin{DoxyParamCaption}
\item[{struct {\bf stack\+\_\+expresion} $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga9fa5406eb5ecac559c4f4c6d36065fb6}{}\label{group__expression__processing_ga9fa5406eb5ecac559c4f4c6d36065fb6}


Function destroys a stack, frees its memory and sets its variables. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em s} & pointer to a stack. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
integer value which tells, how the whole processed has been executed, 0 -\/$>$ no error, !=0 -\/$>$ error. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+empty@{stack\+\_\+expression\+\_\+empty}}
\index{stack\+\_\+expression\+\_\+empty@{stack\+\_\+expression\+\_\+empty}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+empty(const struct stack\+\_\+expresion $\ast$s)}{stack_expression_empty(const struct stack_expresion *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+empty (
\begin{DoxyParamCaption}
\item[{const struct {\bf stack\+\_\+expresion} $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga938c2a69430813da1181adce149b6a5b}{}\label{group__expression__processing_ga938c2a69430813da1181adce149b6a5b}


Function checks whether stack is empty. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & pointer to a stack. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
integer value which tells, if the stack is empty, 0 -\/$>$ not empty, !=0 -\/$>$ empty. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+full@{stack\+\_\+expression\+\_\+full}}
\index{stack\+\_\+expression\+\_\+full@{stack\+\_\+expression\+\_\+full}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+full(const struct stack\+\_\+expresion $\ast$s)}{stack_expression_full(const struct stack_expresion *s)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+full (
\begin{DoxyParamCaption}
\item[{const struct {\bf stack\+\_\+expresion} $\ast$}]{s}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_gae241e2aa86c0b655cdeccdc6ad115631}{}\label{group__expression__processing_gae241e2aa86c0b655cdeccdc6ad115631}


Function checks whether stack is full. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & pointer to a stack. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
integer value which tells, if the stack is full, 0 -\/$>$ not full, !=0 -\/$>$ full. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+init@{stack\+\_\+expression\+\_\+init}}
\index{stack\+\_\+expression\+\_\+init@{stack\+\_\+expression\+\_\+init}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+init(struct stack\+\_\+expresion $\ast$s, int size)}{stack_expression_init(struct stack_expresion *s, int size)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+init (
\begin{DoxyParamCaption}
\item[{struct {\bf stack\+\_\+expresion} $\ast$}]{s, }
\item[{int}]{size}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_gaff5002c4bf81b10b720b056aa0b70c5a}{}\label{group__expression__processing_gaff5002c4bf81b10b720b056aa0b70c5a}


Function initializes a stack, allocates required memory and sets its variables. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em s} & pointer to a stack. \\
\hline
\mbox{\tt in}  & {\em size} & max. number of tokens which stack could contain. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 

size!=0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
s!=N\+U\+LL 
\end{DoxyPostcond}
\begin{DoxyReturn}{Returns}
integer value which tells, how the whole processed has been executed, 0 -\/$>$ no error, !=0 -\/$>$ error. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+pop@{stack\+\_\+expression\+\_\+pop}}
\index{stack\+\_\+expression\+\_\+pop@{stack\+\_\+expression\+\_\+pop}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+pop(struct stack\+\_\+expresion $\ast$s, token $\ast$t)}{stack_expression_pop(struct stack_expresion *s, token *t)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+pop (
\begin{DoxyParamCaption}
\item[{struct {\bf stack\+\_\+expresion} $\ast$}]{s, }
\item[{{\bf token} $\ast$}]{t}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga5185cf48c8ae8e8bc576dea6c0b59b4b}{}\label{group__expression__processing_ga5185cf48c8ae8e8bc576dea6c0b59b4b}


Function pops and gives back top element from the stack. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & pointer to a stack. \\
\hline
\mbox{\tt out}  & {\em t} & top element from the stack. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 

t!=N\+U\+LL 

s is not empty 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
t!=N\+U\+LL 

s-\/$>$size == s-\/$>$size-\/1 
\end{DoxyPostcond}
\begin{DoxyReturn}{Returns}
integer value which tells, how the whole processed has been executed, 0 -\/$>$ no error, !=0 -\/$>$ error. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+push@{stack\+\_\+expression\+\_\+push}}
\index{stack\+\_\+expression\+\_\+push@{stack\+\_\+expression\+\_\+push}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+push(struct stack\+\_\+expresion $\ast$s, token t)}{stack_expression_push(struct stack_expresion *s, token t)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+push (
\begin{DoxyParamCaption}
\item[{struct {\bf stack\+\_\+expresion} $\ast$}]{s, }
\item[{{\bf token}}]{t}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_gaead604dfcdb459a972527f21b8074240}{}\label{group__expression__processing_gaead604dfcdb459a972527f21b8074240}


Function pushes given element to the stack. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & pointer to a stack. \\
\hline
\mbox{\tt out}  & {\em t} & token which should be pushed to the stack. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 

s is not full 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
s-\/$>$size == s-\/$>$size+1 

s-\/$>$arr\mbox{[}s-\/$>$size\mbox{]} == t 
\end{DoxyPostcond}
\begin{DoxyReturn}{Returns}
integer value which tells, how the whole processed has been executed, 0 -\/$>$ no error, !=0 -\/$>$ error. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!stack\+\_\+expression\+\_\+top@{stack\+\_\+expression\+\_\+top}}
\index{stack\+\_\+expression\+\_\+top@{stack\+\_\+expression\+\_\+top}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{stack\+\_\+expression\+\_\+top(struct stack\+\_\+expresion $\ast$s, token $\ast$t)}{stack_expression_top(struct stack_expresion *s, token *t)}}]{\setlength{\rightskip}{0pt plus 5cm}int stack\+\_\+expression\+\_\+top (
\begin{DoxyParamCaption}
\item[{struct {\bf stack\+\_\+expresion} $\ast$}]{s, }
\item[{{\bf token} $\ast$}]{t}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga5798f0a7e7f62997286f1007791f7621}{}\label{group__expression__processing_ga5798f0a7e7f62997286f1007791f7621}


Function gives back top element from the stack. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em s} & pointer to a stack. \\
\hline
\mbox{\tt out}  & {\em t} & top element from the stack. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
s!=N\+U\+LL 

t!=N\+U\+LL 

s is not empty 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
t!=N\+U\+LL 
\end{DoxyPostcond}
\begin{DoxyReturn}{Returns}
integer value which tells, how the whole processed has been executed, 0 -\/$>$ no error, !=0 -\/$>$ error. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!type\+\_\+name\+\_\+convertion@{type\+\_\+name\+\_\+convertion}}
\index{type\+\_\+name\+\_\+convertion@{type\+\_\+name\+\_\+convertion}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{type\+\_\+name\+\_\+convertion(int type)}{type_name_convertion(int type)}}]{\setlength{\rightskip}{0pt plus 5cm}int type\+\_\+name\+\_\+convertion (
\begin{DoxyParamCaption}
\item[{int}]{type}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga78080bfa249f5c45571dbab511d17cc9}{}\label{group__expression__processing_ga78080bfa249f5c45571dbab511d17cc9}


Function converts names of the given data type, so it could be understood by the function \hyperlink{group__expression__processing_ga4c57a10caa30f485a261625f53528f37}{expr\+\_\+analyze()}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em type} & data type symbol. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
converted integer value which tells the what is the given data type. 
\end{DoxyReturn}
\index{Expression processing@{Expression processing}!type\+\_\+priority@{type\+\_\+priority}}
\index{type\+\_\+priority@{type\+\_\+priority}!Expression processing@{Expression processing}}
\subsubsection[{\texorpdfstring{type\+\_\+priority(int type)}{type_priority(int type)}}]{\setlength{\rightskip}{0pt plus 5cm}int type\+\_\+priority (
\begin{DoxyParamCaption}
\item[{int}]{type}
\end{DoxyParamCaption}
)}\hypertarget{group__expression__processing_ga42a0cd1f1765216b8bc8eee79b80c06d}{}\label{group__expression__processing_ga42a0cd1f1765216b8bc8eee79b80c06d}


Function tells the priority of a given data type, which is later used for determining data type of the whole expression. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em type} & data type symbol. \\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
type$>$=0 
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
integer value which tells the priority of a given data type. 
\end{DoxyReturn}
